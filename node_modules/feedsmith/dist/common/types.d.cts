//#region src/common/types.d.ts
type DateLike = Date | string;
type ExtraFields<F extends ReadonlyArray<string>, V = unknown> = { [K in F[number]]?: V };
type IsPlainObject<T> = T extends Array<unknown> ? false : T extends ((...args: Array<unknown>) => unknown) ? false : T extends Date ? false : T extends object ? T extends null ? false : true : false;
type RemoveUndefined<T> = T extends undefined ? never : T;
type DeepPartial<T> = IsPlainObject<T> extends true ? { [P in keyof T]?: DeepPartial<RemoveUndefined<T[P]>> } : T extends Array<infer U> ? Array<DeepPartial<U>> : T;
type DeepOmit<T, K extends string> = T extends Array<infer U> ? Array<DeepOmit<U, K>> : IsPlainObject<T> extends true ? Pick<{ [P in keyof T]: DeepOmit<T[P], K> }, Exclude<keyof T, K>> : T;
type ParseOptions = {
  maxItems?: number;
};
type XmlStylesheet = {
  type: string;
  href: string;
  title?: string;
  media?: string;
  charset?: string;
  alternate?: boolean;
};
type XmlGenerateOptions<O, F extends boolean = false> = O & {
  lenient?: F;
  stylesheets?: Array<XmlStylesheet>;
};
type JsonGenerateOptions<O, F extends boolean = false> = O & {
  lenient?: F;
};
type XmlGenerateMain<S, L, O = Record<string, unknown>> = <F extends boolean = false>(value: F extends true ? L : S, options?: XmlGenerateOptions<O, F>) => string;
type JsonGenerateMain<S, L, O = Record<string, unknown>> = <F extends boolean = false>(value: F extends true ? L : S, options?: JsonGenerateOptions<O, F>) => unknown;
//#endregion
export { DateLike, DeepOmit, DeepPartial, ExtraFields, JsonGenerateMain, ParseOptions, XmlGenerateMain, XmlGenerateOptions };